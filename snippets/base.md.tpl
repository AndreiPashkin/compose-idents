{{- $h1 := tmpl.Exec "heading" (dict "headings_level" .headings_level "level" 0) -}}
{{- $h2 := tmpl.Exec "heading" (dict "headings_level" .headings_level "level" 1) -}}
{{- $h3 := tmpl.Exec "heading" (dict "headings_level" .headings_level "level" 2) -}}
{{- $h4 := tmpl.Exec "heading" (dict "headings_level" .headings_level "level" 3) -}}

A macro for generating new identifiers (names of variables, functions, traits, etc.) by concatenating one or more
arbitrary parts, applying other manipulations, and iteratively generating multiple variations of the supplied Rust code.

It was created as an alternative to `macro_rules!` that doesn't allow creating new identifiers from the macro arguments
and [`concat_idents!`][1] macro from the nightly Rust, which is limited in capabilities and has not been stabilized
[since 2015][2].

[1]: https://doc.rust-lang.org/std/macro.concat_idents.html
[2]: https://github.com/rust-lang/rust/issues/29599

{{ $h1 }} Features

- **Identifier generation**

  Identifiers can be generated via concatenation of multiple parts. Arguments of the outer macro
  definitions and literals are supported for identifier definitions.
- **Code repetition**

  Generation of multiple variations of the user-provided code is natively supported via `for ... in ...` loop syntax.
- **Functions**

  Functions can be applied when defining new identifiers for changing case and style.
- **String formatting**

  Strings can be formatted with `% alias %` syntax, which is useful for generating doc-attributes.
- **Unique identifier generation**

  Unique identifiers can be deterministically generated by using the `hash()` function, which is seeded uniquely
  for each invocation of the macro. This might be useful for generating unique global variables.

{{ $h1 }} Usage

This section contains various usage examples. For additional examples, see the tests/ directory of the repository.

{{ $h2 }} Quick start

`compose!` works by accepting definitions of aliases and a code block where aliases
could be used as normal identifiers. When the macro is expanded, the aliases are replaced with their
definitions (which may expand into identifiers, paths, expressions, and arbitrary Rust code):
```rust
use compose_idents::compose;

/// Generate getters, setters with docstrings for given struct
struct User {
    name: String,
    age: u32,
    email: Option<String>,
}

impl User {
    compose!(
        // Iterating over fields and their types, generating a new variation of the code per iteration
        for (field, type_) in [(name, String), (age, u32), (email, Option<String>)]

        // Definitions of additional aliases
        getter = field,
        setter = concat(set_, field),
        getter_mut = concat(field, _mut),
        {
            #[doc = "Get the % field % field"]
            pub fn getter(&self) -> &type_ {
                &self.field
            }

            #[doc = "Get mutable reference to % field % field"]
            pub fn getter_mut(&mut self) -> &mut type_ {
                &mut self.field
            }

            #[doc = "Set the % field % field"]
            pub fn setter(&mut self, value: type_) {
                self.field = value;
            }
        }
    );
}

let mut user = User { name: "Alice".into(), age: 30, email: None };
user.set_name("Bob".into());
user.set_email(Some("bob@example.com".into()));
assert_eq!(user.name(), "Bob");
```

{{ $h2 }} Generating tests for different types

A practical example for how to auto-generate names for macro-generated tests for different data types:
```rust
use compose_idents::compose;

pub trait Frobnicate {
  type Output;

  fn frobnicate(&self, value: Self) -> Self::Output;
}

impl Frobnicate for u32 {
  type Output = u32;

  fn frobnicate(&self, value: Self) -> Self::Output {
    self + value
  }
}

impl Frobnicate for &'static str {
  type Output = String;

  fn frobnicate(&self, value: Self) -> Self::Output {
    format!("{}_{}", self, value)
  }
}

// Generates tests for u32 and &'static str types
compose!(
  for (type_, initial, input, expected_value) in [
    (u32, 0, 42_u32, 42_u32),
    (&'static str, "foo", "bar", "foo_bar".to_string()),
  ]

  // Notice - we are using normalize2() to make `&'static str` fit for
  // being part of the test function's identifier.
  test_fn = concat(test_frobnicate_, normalize2(type_)),
  {
    fn test_fn() {
      let actual = (initial as type_).frobnicate(input);
      let expected = expected_value;

      assert_eq!(actual, expected);
    }
  }
);

test_frobnicate_u32();
// Notice - "&'static str" has been turned into just "static_str"
test_frobnicate_static_str();
```

{{ $h1 }} Reference

{{ tpl (file.Read "snippets/reference.md.tpl") (dict "headings_level" 3) -}}
{{- printf "\n" -}}


{{ $h1 }} Backwards compatibility and deprecation

{{ $h2 }} Deprecation policy

- As a general rule old functionality is not removed abruptly, but rather deprecated first and removed after
  a few releases. This applies to pre-1.0.0 releases as well.
- Deprecation works through injection of `#[deprecated]` attributes to existing syntactic elements of generated code.
  It triggers deprecation warnings at compile time with text like this:
  ```text,ignore
  compose!: Feature XXX is deprecated, syntax `compose!(...)` is considered obsolete, please use...
  ```
- Removal of a feature without a deprecation process is only possible in pre-1.0.0 releases and in such a case an
  explicit warning is issued in the changelog and the release notes.
- A deprecated feature is kept for a reasonably long time, or until backwards-compatibility can't be maintained anymore,
  or it becomes too costly, then it is removed completely.

{{ $h2 }} Migration guides

This section describes what to do to migrate code that uses deprecated features to up-to-date state.

{{ $h3 }} [≤ 0.0.4 → 0.0.5+]: Semicolon alias separator

{{ $h4 }} What changed?

Starting with `v0.0.5` commas were introduced as a separator of alias definitions. The old semicolon separator is
deprecated.

{{ $h4 }} How to migrate?

Before (≤ 0.0.4):

```rust,ignore
compose_idents!(
    my_fn  = concat(foo, bar);  // ← Notice usage of semicolons
    MY_VAR = concat(FOO, BAZ);
    {
        /* … */
    };
);
```

After (0.0.5+):

```rust,ignore
compose_idents!(
    my_fn  = concat(foo, bar),  // ← Notice usage of commas
    MY_VAR = concat(FOO, BAZ),
    {
        /* … */
    },
);
```

User should simply replace every semicolon separator in the macro invocation with a comma.

{{ $h3 }} [≤ 0.2.0 → 0.2.2]: Bracket-based alias syntax

{{ $h4 }} What changed?

`v0.2.0` deprecated and `v0.2.2` removed support for the square-bracket form: `alias = [arg1, func(arg2), …]`, of alias
definitions in favour of bare expressions without any special block delimiters: `alias = concat(arg1, func(arg2), …)`,
or `alias = func(arg1)`, or `alias = func(arg1)`, or just `alias = arg`.

{{ $h4 }} How to migrate?

Before (≤ 0.2.0):

```rust,ignore
compose_idents!(
    my_fn    = [foo, _, bar],  // Notice usage of brackets
    MY_CONST = [upper(baz)],
    {
        /* … */
    },
);
```

After (≥ 0.2.0, ≤ v0.2.2):

```rust,ignore
compose_idents!(
    my_fn    = concat(foo, _, bar),  // Notice - brackets are replaced with `concat()` call
    MY_CONST = upper(baz),  // No need for `concat()` since only a single argument is present
    {
        /* … */
    },
);
```

1. Wrap comma-separated arguments in `concat( … )`.
2. Or use the appropriate function (`upper()`, `lower()`, etc.) directly when only one argument is present.
3. Or Use the argument itself if no transformation is needed.

{{ $h3 }} [≤ 0.2.2 → 0.3.0]: Macro rename compose_idents! → compose!

{{ $h4 }} What changed?

Starting with `v0.3.0` `compose_idents!` was renamed from to `compose!`.

{{ $h4 }} How to migrate?

Before (≤ 0.2.2):

```rust,ignore
use compose_idents::compose_idents;

compose_idents!(
    my_fn = concat(foo, _, bar),
    {
        fn my_fn() {}
    },
);
```

After (≥ 0.3.0):

```rust,ignore
use compose_idents::compose;

compose!(
    my_fn = concat(foo, _, bar),
    {
        fn my_fn() {}
    },
);
```

Simply replace `use compose_idents::compose_idents;` with `use compose_idents::compose;` and rename macro invocations
from `compose_idents!(...)` to `compose!(...)`.

{{ $h1 }} Alternatives

There are some other tools and projects dedicated to identifier manipulation:

- A macro from Nightly Rust that allows to concatenate identifiers. It is limited in functionality and nowhere near
  to be stabilized:
  <https://doc.rust-lang.org/std/macro.concat_idents.html>
- A very similar macro that doesn't support multiple aliases and is not maintained:
  <https://github.com/DzenanJupic/concat-idents>
- A macro that allows to define and refer to unique temporary variables:
  <https://crates.io/crates/templest>

{{ $h1 }} Development

The following standards are followed to maintain the project:
- <https://www.conventionalcommits.org/en/v1.0.0/>
- <https://semver.org/>
- <https://keepachangelog.com/en/1.1.0/>
- <https://adr.github.io/madr/>
