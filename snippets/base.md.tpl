{{- $h1 := tmpl.Exec "heading" (dict "headings_level" .headings_level "level" 0) -}}
{{- $h2 := tmpl.Exec "heading" (dict "headings_level" .headings_level "level" 1) -}}
{{- $h3 := tmpl.Exec "heading" (dict "headings_level" .headings_level "level" 2) -}}
{{- $h4 := tmpl.Exec "heading" (dict "headings_level" .headings_level "level" 3) -}}

A macro for generating new identifiers (names of variables, functions, traits, etc.) by concatenating one or more
arbitrary parts and applying other manipulations.

It was created as an alternative to `macro_rules!` that doesn't allow creating new identifiers from the macro arguments
and [`concat_idents!`][1] macro from the nightly Rust, which is limited in capabilities and has not been stabilized
[since 2015][2].

```rust
compose_idents::compose_idents!(
    my_fn = concat(foo, _, "baz"),
    {
        fn my_fn() -> u32 {
            42
        }
    },
);

assert_eq!(foo_baz(), 42);
```

[1]: https://doc.rust-lang.org/std/macro.concat_idents.html
[2]: https://github.com/rust-lang/rust/issues/29599

{{ $h1 }} Features

- **Identifier generation**

  Identifiers can be generated via concatenation of multiple parts. Arguments of the outer macro
  definitions and literals are supported for identifier definitions.
- **Functions**

  Functions can be applied when defining new identifiers for changing case and style.
- **String formatting**

  Strings can be formatted with `%alias%` syntax, which is useful for generating doc-attributes.
- **Unique identifier generation**

  Unique identifiers can be deterministically generated by using the `hash()` function, which is seeded uniquely
  for each invocation of the macro. This might be useful for generating unique global variables.

{{ $h1 }} Usage

This section contains various usage examples. For additional examples, see the tests/ directory of the repository.

{{ $h2 }} Quick start

`compose_idents!` works by accepting definitions of aliases and a code block where aliases
could be used as normal identifiers. When the macro is expanded, the aliases are replaced with their
definitions:
```rust
use compose_idents::compose_idents;

// We generate separate const-functions for each type as a workaround
// since Rust doesn't allow us to use `core::ops::Add` in `const fn`.

macro_rules! gen_const_add {
    ($T:ty) => {
        compose_idents!(
            Type = upper($T),           // Alias for the type - make it uppercase in addition
            add_fn = concat(add_, $T),  // Alias for the function name
            {
                // Strings (including in doc-attributes) can be formatted with %alias% syntax.
                #[doc = "Adds two arguments of type `%Type%` at compile time."]
                pub const fn add_fn(a: $T, b: $T) -> $T {  // Aliases are used as normal identifiers
                    a + b
                }
            }
        );
    };
}

gen_const_add!(u32);  // Expands into `add_u32()` function.
gen_const_add!(u64);  // Expands into `add_u64()` function.

assert_eq!(add_u32(2_u32, 2_u32), 4_u32);
assert_eq!(add_u64(2_u64, 2_u64), 4_u64);
```

{{ $h2 }} Generating tests for different types

A practical example for how to auto-generate names for macro-generated tests for different data types:
```rust
use compose_idents::compose_idents;

pub trait Frobnicate {
  type Output;

  fn frobnicate(&self, value: Self) -> Self::Output;
}

impl Frobnicate for u32 {
  type Output = u32;

  fn frobnicate(&self, value: Self) -> Self::Output {
    self + value
  }
}

impl Frobnicate for &'static str {
  type Output = String;

  fn frobnicate(&self, value: Self) -> Self::Output {
    format!("{}_{}", self, value)
  }
}

macro_rules! generate_frobnicate_test {
    ($type:ty, $initial:expr, $input:expr, $expected:expr) => {
        // Notice - we are using normalize() to make `&'static str` fit for
        // being part of the test function's identifier.
        compose_idents!(test_fn = concat(test_frobnicate_, normalize($type)), {
          fn test_fn() {
            let actual = ($initial as $type).frobnicate($input);
            let expected = $expected;

            assert_eq!(actual, expected);
          }
        });
    };
}

// Generates tests for u32 and &'static str types
generate_frobnicate_test!(u32, 0, 42_u32, 42_u32);
generate_frobnicate_test!(&'static str, "foo", "bar", "foo_bar".to_string());

test_frobnicate_u32();
// Notice - "&'static str" has been turned into just "static_str"
test_frobnicate_static_str();
```

{{ $h1 }} Reference

{{ tpl (file.Read "snippets/reference.md.tpl") (dict "headings_level" 3) -}}
{{- printf "\n" -}}


{{ $h1 }} Backwards compatibility and deprecation

{{ $h2 }} Deprecation policy

- As a general rule old functionality is not removed abruptly, but rather deprecated first and removed after
  a few releases. This applies to pre-1.0.0 releases as well.
- Deprecation works through injection of `#[deprecated]` attributes to existing syntactic elements of generated code.
  It triggers deprecation warnings at compile time with text like this:
  ```text,ignore
  compose_idents!: Feature XXX is deprecated, syntax `compose_idents!(...)` is considered obsolete, please use...
  ```
- Removal of a feature without a deprecation process is only possible in pre-1.0.0 releases and in such a case an
  explicit warning is issued in the changelog and the release notes.
- A deprecated feature is kept for a reasonably long time, or until backwards-compatibility can't be maintained anymore,
  or it becomes too costly, then it is removed completely.

{{ $h2 }} Migration guides

This section describes what to do to migrate code that uses deprecated features to up-to-date state.

{{ $h3 }} [≤ 0.0.4 → 0.0.5+]: Semicolon alias separator

{{ $h4 }} What changed?

Starting with `v0.0.5` commas were introduced as a separator of alias definitions. The old semicolon separator is
deprecated.

{{ $h4 }} How to migrate?

Before (≤ 0.0.4):

```rust,ignore
compose_idents!(
    my_fn  = concat(foo, bar);  // ← Notice usage of semicolons
    MY_VAR = concat(FOO, BAZ);
    {
        /* … */
    };
);
```

After (0.0.5+):

```rust,ignore
compose_idents!(
    my_fn  = concat(foo, bar),  // ← Notice usage of commas
    MY_VAR = concat(FOO, BAZ),
    {
        /* … */
    },
);
```

User should simply replace every semicolon separator in the macro invocation with a comma.

{{ $h3 }} [≤ 0.2.0 → 0.2.0+]: Bracket-based alias syntax

{{ $h4 }} What changed?

`v0.2.0` deprecated the square-bracket form: `alias = [arg1, func(arg2), …]`, of alias definitions in favour of bare
expressions without any special block delimiters: `alias = concat(arg1, func(arg2), …)`, or `alias = func(arg1)`, or
just `alias = arg`.

{{ $h4 }} How to migrate?

Before (≤ 0.2.0):

```rust,ignore
compose_idents!(
    my_fn    = [foo, _, bar],  // Notice usage of brackets
    MY_CONST = [upper(baz)],
    {
        /* … */
    },
);
```

After (0.2.0+):

```rust,ignore
compose_idents!(
    my_fn    = concat(foo, _, bar),  // Notice - brackets are replaced with `concat()` call
    MY_CONST = upper(baz),  // No need for `concat()` since only a single argument is present
    {
        /* … */
    },
);
```

1. Wrap comma-separated arguments in `concat( … )`.
2. Or use the appropriate function (`upper()`, `lower()`, etc.) directly when only one argument is present.
3. Or Use the argument itself if no transformation is needed.

{{ $h1 }} Alternatives

There are some other tools and projects dedicated to identifier manipulation:

- A macro from Nightly Rust that allows to concatenate identifiers. It is limited in functionality and nowhere near
  to be stabilized:
  <https://doc.rust-lang.org/std/macro.concat_idents.html>
- A very similar macro that doesn't support multiple aliases and is not maintained:
  <https://github.com/DzenanJupic/concat-idents>
- A macro that allows to define and refer to unique temporary variables:
  <https://crates.io/crates/templest>

{{ $h1 }} Development

The following standards are followed to maintain the project:
- <https://www.conventionalcommits.org/en/v1.0.0/>
- <https://semver.org/>
- <https://keepachangelog.com/en/1.1.0/>
- <https://adr.github.io/madr/>
