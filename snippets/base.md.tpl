{{- $h1 := tmpl.Exec "heading" (dict "headings_level" .headings_level "level" 0) -}}
{{- $h2 := tmpl.Exec "heading" (dict "headings_level" .headings_level "level" 1) -}}

A macro for generating new identifiers (names of variables, functions, traits, etc.) by concatenating one or more
arbitrary parts and applying other manipulations.

It was created as an alternative to `macro_rules!` that doesn't allow creating new identifiers from the macro arguments
and [`concat_idents!`][1] macro from the nightly Rust, which is limited in capabilities and has not been stabilized
[since 2015][2].

```rust
compose_idents::compose_idents!(
    my_fn = concat(foo, _, "baz"),
    {
        fn my_fn() -> u32 {
            42
        }
    },
);

assert_eq!(foo_baz(), 42);
```

[1]: https://doc.rust-lang.org/std/macro.concat_idents.html
[2]: https://github.com/rust-lang/rust/issues/29599

{{ $h1 }} Features

- **Identifier generation**

  Identifiers can be generated via concatenation of multiple parts. Arguments of the outer macro
  definitions and literals are supported for identifier definitions.
- **Functions**

  Functions can be applied when defining new identifiers for changing case and style.
- **String formatting**

  Strings can be formatted with `%alias%` syntax, which is useful for generating doc-attributes.
- **Unique identifier generation**

  Unique identifiers can be deterministically generated by using `hash()` function which is uniquely
  seeded each invocation of the macro. This might be useful for generating unique global variables.

{{ $h1 }} Usage

This section contains various usage examples. For even more usage examples look into `tests/` directory
of the repository.

{{ $h2 }} Quick start

`compose_idents!` works by accepting definitions of aliases and a code block where aliases
could be used as normal identifiers. When the macro is expanded, the aliases are replaced with their
definitions:
```rust
use compose_idents::compose_idents;

// We generate separate const-functions for each type as a workaround
// since Rust doesn't allow us to use `core::ops::Add` in `const fn`.

macro_rules! gen_const_add {
    ($T:ty) => {
        compose_idents!(
            Type = upper($T),           // Alias for the type - make it uppercase in addition
            add_fn = concat(add_, $T),  // Alias for the function name
            {
                // Strings (including in doc-attributes) can be formatted with %alias% syntax.
                #[doc = "Adds two arguments of type `%Type%` at compile time."]
                pub const fn add_fn(a: $T, b: $T) -> $T {  // Aliases are used as normal identifiers
                    a + b
                }
            }
        );
    };
}

gen_const_add!(u32);  // Expands into `add_u32()` function.
gen_const_add!(u64);  // Expands into `add_u64()` function.

assert_eq!(add_u32(2_u32, 2_u32), 4_u32);
assert_eq!(add_u64(2_u64, 2_u64), 4_u64);
```

{{ $h2 }} Generating tests for different types

A practical example for how to auto-generate names for macro-generated tests for different data types:
```rust
use compose_idents::compose_idents;

pub trait Frobnicate {
  type Output;

  fn frobnicate(&self, value: Self) -> Self::Output;
}

impl Frobnicate for u32 {
  type Output = u32;

  fn frobnicate(&self, value: Self) -> Self::Output {
    self + value
  }
}

impl Frobnicate for &'static str {
  type Output = String;

  fn frobnicate(&self, value: Self) -> Self::Output {
    format!("{}_{}", self, value)
  }
}

macro_rules! generate_frobnicate_test {
    ($type:ty, $initial:expr, $input:expr, $expected:expr) => {
        // Notice - we are using normalize() to make `&'static str` fit for
        // being part of the test function's identifier.
        compose_idents!(test_fn = concat(test_frobnicate_, normalize($type)), {
          fn test_fn() {
            let actual = ($initial as $type).frobnicate($input);
            let expected = $expected;

            assert_eq!(actual, expected);
          }
        });
    };
}

// Generates tests for u32 and &'static str types
generate_frobnicate_test!(u32, 0, 42_u32, 42_u32);
generate_frobnicate_test!(&'static str, "foo", "bar", "foo_bar".to_string());

test_frobnicate_u32();
// Notice - "&'static str" has been turned into just "static_str"
test_frobnicate_static_str();
```

{{ $h1 }} Reference

{{ tpl (file.Read "snippets/reference.md.tpl") (dict "headings_level" 3) -}}
{{- printf "\n" -}}

{{ $h1 }} Deprecation policy

- As a general rule old functionality is not removed abruptly, but rather deprecated first and removed after
  a few releases.
- Deprecation works by injecting `#[deprecated]` attribute to existing syntactic elements of generated code
  without adding new ones. It might not work in corner cases if there is no place where the attribute could be added.

  Here is how a deprecation warning might look like:
  ```text,ignore
  warning: use of deprecated function `my_function`: compose_idents!: Using semicolons as separators is deprecated, use commas instead
  ```

{{ $h1 }} Alternatives

There some other tools and projects dedicated to identifier manipulation:

- A macro from Nightly Rust that allows to concatenate identifiers. It is limited in functionality and nowhere near
  to be stabilized:
  <https://doc.rust-lang.org/std/macro.concat_idents.html>
- A very similar macro that doesn't support multiple aliases and is not maintained:
  <https://github.com/DzenanJupic/concat-idents>
- A macro that allows to define and refer to unique temporary variables:
  <https://crates.io/crates/templest>

{{ $h1 }} Development

The following standards are followed to maintain the project:
- <https://www.conventionalcommits.org/en/v1.0.0/>
- <https://semver.org/>
- <https://keepachangelog.com/en/1.1.0/>
- <https://adr.github.io/madr/>
